import { Injectable } from '@nestjs/common';
import * as Logger from 'bunyan';
import * as ejs from 'ejs';
import { Permit } from './permits.repository';
import * as pdf from 'html-pdf';
import { CreateOptions } from 'html-pdf';
import * as streams from 'stream';
import { createLogger, StorageProvider } from '@3wks/gae-node-nestjs';

@Injectable()
export class PermitPdfService {
  private readonly logger: Logger;
  private readonly template: string;

  constructor(private readonly storageProvider: StorageProvider) {
    this.logger = createLogger('pdf');
    this.template = './src/permits/template.html';
  }

  generatePdf(
    permit: Permit,
  ): Promise<{ pdfUrl: string; pdf: streams.Readable }> {
    this.logger.info(`Generating PDF`);
    return new Promise((resolve, reject) => {
      ejs.renderFile(this.template, { permit }, (ejsError, html) => {
        if (ejsError) {
          this.logger.error('Error rendering EJS template');
          reject(ejsError);
        }

        if (html) {
          const options: CreateOptions = {
            format: 'A4',
            orientation: 'portrait',
            border: '1cm',
          };
          pdf.create(html, options).toStream((pdfError, stream) => {
            if (pdfError) {
              this.logger.error('Error creating PDF');
              reject(pdfError);
            }

            const filename = this.generateFilename(permit);
            const file = this.storageProvider.defaultBucket.file(filename);
            const toStorageStream = new streams.PassThrough();
            const asFileStream = new streams.PassThrough();

            stream.pipe(toStorageStream);
            stream.pipe(asFileStream);

            toStorageStream.pipe(file.createWriteStream());

            this.logger.info('Done');
            resolve({
              pdfUrl: `gs://${
                this.storageProvider.defaultBucket.name
              }/${filename}`,
              pdf: asFileStream,
            });
          });
        } else {
          reject('Cannot render PDF, no html was generated by the template');
        }
      });
    });
  }

  private generateFilename(permit: Permit) {
    return `pdf/${permit.id}.pdf`;
  }

  async getDownloadUrl(permit: Permit): Promise<string> {
    if (!permit.pdfUrl) {
      throw new Error(`No pdf for permit ${permit.id}`);
    }

    const [url] = await this.storageProvider.defaultBucket
      .file(this.generateFilename(permit))
      .getSignedUrl({
        action: 'read',
        responseType: 'application/pdf',
        expires: Date.now() + 1000 * 60 * 5,
      });

    return url;
  }
}
